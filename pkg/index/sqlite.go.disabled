package index

import (
	"context"
	"database/sql"
	"fmt"
	"strings"
	"sync"
	"time"

	_ "modernc.org/sqlite" // Pure Go SQLite driver
)

// SQLiteIndex implements Index using SQLite FTS5.
type SQLiteIndex struct {
	mu      sync.RWMutex
	db      *sql.DB
	path    string
	closed  bool
	chunker *Chunker
	parser  *Parser
}

// NewSQLiteIndex creates a new SQLite-backed index.
func NewSQLiteIndex(path string) (*SQLiteIndex, error) {
	db, err := sql.Open("sqlite", path)
	if err != nil {
		return nil, fmt.Errorf("open database: %w", err)
	}

	idx := &SQLiteIndex{
		db:      db,
		path:    path,
		chunker: NewChunker(50, 10),
		parser:  NewParser(),
	}

	if err := idx.init(); err != nil {
		db.Close()
		return nil, err
	}

	return idx, nil
}

// init creates the database schema.
func (idx *SQLiteIndex) init() error {
	schema := `
		-- Files table
		CREATE TABLE IF NOT EXISTS files (
			id INTEGER PRIMARY KEY,
			path TEXT UNIQUE NOT NULL,
			content TEXT,
			language TEXT,
			size INTEGER,
			mod_time INTEGER,
			hash TEXT,
			created_at INTEGER DEFAULT (strftime('%s', 'now')),
			updated_at INTEGER DEFAULT (strftime('%s', 'now'))
		);
		CREATE INDEX IF NOT EXISTS idx_files_path ON files(path);
		CREATE INDEX IF NOT EXISTS idx_files_language ON files(language);

		-- Chunks table with FTS5
		CREATE VIRTUAL TABLE IF NOT EXISTS chunks_fts USING fts5(
			path,
			content,
			language,
			tokenize='porter unicode61'
		);

		-- Chunks metadata table
		CREATE TABLE IF NOT EXISTS chunks (
			id TEXT PRIMARY KEY,
			file_id INTEGER REFERENCES files(id) ON DELETE CASCADE,
			path TEXT NOT NULL,
			start_line INTEGER,
			end_line INTEGER,
			content TEXT,
			language TEXT,
			hash TEXT,
			created_at INTEGER DEFAULT (strftime('%s', 'now'))
		);
		CREATE INDEX IF NOT EXISTS idx_chunks_file_id ON chunks(file_id);
		CREATE INDEX IF NOT EXISTS idx_chunks_path ON chunks(path);

		-- Symbols table
		CREATE TABLE IF NOT EXISTS symbols (
			id INTEGER PRIMARY KEY,
			file_id INTEGER REFERENCES files(id) ON DELETE CASCADE,
			chunk_id TEXT REFERENCES chunks(id) ON DELETE CASCADE,
			name TEXT NOT NULL,
			kind TEXT NOT NULL,
			path TEXT NOT NULL,
			line INTEGER,
			column INTEGER,
			end_line INTEGER,
			signature TEXT,
			documentation TEXT,
			parent TEXT,
			created_at INTEGER DEFAULT (strftime('%s', 'now'))
		);
		CREATE INDEX IF NOT EXISTS idx_symbols_file_id ON symbols(file_id);
		CREATE INDEX IF NOT EXISTS idx_symbols_name ON symbols(name);
		CREATE INDEX IF NOT EXISTS idx_symbols_kind ON symbols(kind);

		-- Symbols FTS for searching
		CREATE VIRTUAL TABLE IF NOT EXISTS symbols_fts USING fts5(
			name,
			signature,
			documentation,
			tokenize='porter unicode61'
		);
	`

	_, err := idx.db.Exec(schema)
	return err
}

// IndexFile indexes a single file.
func (idx *SQLiteIndex) IndexFile(ctx context.Context, path string, content []byte) error {
	idx.mu.Lock()
	defer idx.mu.Unlock()

	if idx.closed {
		return ErrClosed
	}

	language := LanguageFromPath(path)
	contentStr := string(content)
	hash := hashContent(contentStr)

	// Check if file exists and hasn't changed
	var existingHash string
	err := idx.db.QueryRowContext(ctx,
		"SELECT hash FROM files WHERE path = ?", path).Scan(&existingHash)
	if err == nil && existingHash == hash {
		return nil // File unchanged
	}

	// Start transaction
	tx, err := idx.db.BeginTx(ctx, nil)
	if err != nil {
		return fmt.Errorf("begin transaction: %w", err)
	}
	defer tx.Rollback()

	// Delete existing file data
	var fileID int64
	err = tx.QueryRowContext(ctx, "SELECT id FROM files WHERE path = ?", path).Scan(&fileID)
	if err == nil {
		// Delete related data
		_, _ = tx.ExecContext(ctx, "DELETE FROM chunks_fts WHERE path = ?", path)
		_, _ = tx.ExecContext(ctx, "DELETE FROM chunks WHERE file_id = ?", fileID)
		_, _ = tx.ExecContext(ctx, "DELETE FROM symbols WHERE file_id = ?", fileID)
		_, _ = tx.ExecContext(ctx, "DELETE FROM symbols_fts WHERE rowid IN (SELECT id FROM symbols WHERE file_id = ?)", fileID)
		_, _ = tx.ExecContext(ctx, "DELETE FROM files WHERE id = ?", fileID)
	}

	// Insert file
	result, err := tx.ExecContext(ctx,
		`INSERT INTO files (path, content, language, size, mod_time, hash, updated_at)
		 VALUES (?, ?, ?, ?, ?, ?, strftime('%s', 'now'))`,
		path, contentStr, language, len(content), time.Now().Unix(), hash)
	if err != nil {
		return fmt.Errorf("insert file: %w", err)
	}

	fileID, err = result.LastInsertId()
	if err != nil {
		return fmt.Errorf("get file id: %w", err)
	}

	// Parse symbols
	symbols := idx.parser.Parse(path, contentStr, language)

	// Create chunks
	chunks := idx.chunker.ChunkWithSymbols(path, contentStr, language, symbols)

	// Insert chunks
	for _, chunk := range chunks {
		_, err := tx.ExecContext(ctx,
			`INSERT INTO chunks (id, file_id, path, start_line, end_line, content, language, hash)
			 VALUES (?, ?, ?, ?, ?, ?, ?, ?)`,
			chunk.ID, fileID, chunk.Path, chunk.StartLine, chunk.EndLine,
			chunk.Content, chunk.Language, chunk.Hash)
		if err != nil {
			return fmt.Errorf("insert chunk: %w", err)
		}

		// Insert into FTS
		_, err = tx.ExecContext(ctx,
			`INSERT INTO chunks_fts (rowid, path, content, language)
			 VALUES (last_insert_rowid(), ?, ?, ?)`,
			chunk.Path, chunk.Content, chunk.Language)
		if err != nil {
			return fmt.Errorf("insert chunk fts: %w", err)
		}
	}

	// Insert symbols
	for _, sym := range symbols {
		result, err := tx.ExecContext(ctx,
			`INSERT INTO symbols (file_id, name, kind, path, line, column, end_line, signature, documentation, parent)
			 VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
			fileID, sym.Name, string(sym.Kind), sym.Path, sym.Line, sym.Column,
			sym.EndLine, sym.Signature, sym.Documentation, sym.Parent)
		if err != nil {
			return fmt.Errorf("insert symbol: %w", err)
		}

		symbolID, _ := result.LastInsertId()

		// Insert into symbols FTS
		_, err = tx.ExecContext(ctx,
			`INSERT INTO symbols_fts (rowid, name, signature, documentation)
			 VALUES (?, ?, ?, ?)`,
			symbolID, sym.Name, sym.Signature, sym.Documentation)
		if err != nil {
			return fmt.Errorf("insert symbol fts: %w", err)
		}
	}

	return tx.Commit()
}

// IndexDirectory indexes all files in a directory.
func (idx *SQLiteIndex) IndexDirectory(ctx context.Context, root string, opts IndexOptions) error {
	walker := NewWalker(opts)
	return walker.Walk(ctx, root, func(path string, content []byte) error {
		return idx.IndexFile(ctx, path, content)
	})
}

// RemoveFile removes a file from the index.
func (idx *SQLiteIndex) RemoveFile(ctx context.Context, path string) error {
	idx.mu.Lock()
	defer idx.mu.Unlock()

	if idx.closed {
		return ErrClosed
	}

	_, err := idx.db.ExecContext(ctx, "DELETE FROM files WHERE path = ?", path)
	return err
}

// Search performs full-text search.
func (idx *SQLiteIndex) Search(ctx context.Context, query string, opts SearchOptions) ([]SearchResult, error) {
	idx.mu.RLock()
	defer idx.mu.RUnlock()

	if idx.closed {
		return nil, ErrClosed
	}

	if opts.MaxResults == 0 {
		opts.MaxResults = 100
	}

	// Build FTS query
	ftsQuery := buildFTSQuery(query)

	rows, err := idx.db.QueryContext(ctx, `
		SELECT c.path, c.start_line, c.content, bm25(chunks_fts) as score
		FROM chunks_fts
		JOIN chunks c ON chunks_fts.rowid = c.rowid
		WHERE chunks_fts MATCH ?
		ORDER BY score
		LIMIT ?
	`, ftsQuery, opts.MaxResults)
	if err != nil {
		return nil, fmt.Errorf("search: %w", err)
	}
	defer rows.Close()

	var results []SearchResult
	for rows.Next() {
		var r SearchResult
		var content string
		if err := rows.Scan(&r.Path, &r.Line, &content, &r.Score); err != nil {
			return nil, fmt.Errorf("scan: %w", err)
		}

		// Find matching line
		r.Line, r.Content = findMatchingLine(content, query, r.Line)

		if opts.IncludeContent && opts.ContextLines > 0 {
			r.ContextBefore, r.ContextAfter = getContext(content, r.Line, opts.ContextLines)
		}

		results = append(results, r)
	}

	return results, rows.Err()
}

// FindSymbol finds symbols by name and kind.
func (idx *SQLiteIndex) FindSymbol(ctx context.Context, name string, kind SymbolKind) ([]Symbol, error) {
	idx.mu.RLock()
	defer idx.mu.RUnlock()

	if idx.closed {
		return nil, ErrClosed
	}

	query := `
		SELECT name, kind, path, line, column, end_line, signature, documentation, parent
		FROM symbols
		WHERE name LIKE ?
	`
	args := []any{"%" + name + "%"}

	if kind != "" {
		query += " AND kind = ?"
		args = append(args, string(kind))
	}

	query += " ORDER BY name LIMIT 100"

	rows, err := idx.db.QueryContext(ctx, query, args...)
	if err != nil {
		return nil, fmt.Errorf("find symbol: %w", err)
	}
	defer rows.Close()

	var symbols []Symbol
	for rows.Next() {
		var s Symbol
		var kindStr string
		if err := rows.Scan(&s.Name, &kindStr, &s.Path, &s.Line, &s.Column,
			&s.EndLine, &s.Signature, &s.Documentation, &s.Parent); err != nil {
			return nil, fmt.Errorf("scan: %w", err)
		}
		s.Kind = SymbolKind(kindStr)
		symbols = append(symbols, s)
	}

	return symbols, rows.Err()
}

// FindReferences finds references to a symbol.
func (idx *SQLiteIndex) FindReferences(ctx context.Context, symbol Symbol) ([]Reference, error) {
	idx.mu.RLock()
	defer idx.mu.RUnlock()

	if idx.closed {
		return nil, ErrClosed
	}

	// Search for symbol name in chunks
	results, err := idx.Search(ctx, symbol.Name, SearchOptions{
		MaxResults:     100,
		IncludeContent: true,
	})
	if err != nil {
		return nil, err
	}

	var refs []Reference
	for _, r := range results {
		ref := Reference{
			Path:         r.Path,
			Line:         r.Line,
			Column:       r.Column,
			Content:      r.Content,
			IsDefinition: r.Path == symbol.Path && r.Line == symbol.Line,
		}
		refs = append(refs, ref)
	}

	return refs, nil
}

// GetContext retrieves relevant code chunks up to token budget.
func (idx *SQLiteIndex) GetContext(ctx context.Context, query string, maxTokens int) ([]Chunk, error) {
	idx.mu.RLock()
	defer idx.mu.RUnlock()

	if idx.closed {
		return nil, ErrClosed
	}

	// Search for relevant chunks
	ftsQuery := buildFTSQuery(query)

	rows, err := idx.db.QueryContext(ctx, `
		SELECT c.id, c.path, c.start_line, c.end_line, c.content, c.language, bm25(chunks_fts) as score
		FROM chunks_fts
		JOIN chunks c ON chunks_fts.rowid = c.rowid
		WHERE chunks_fts MATCH ?
		ORDER BY score
		LIMIT 50
	`, ftsQuery)
	if err != nil {
		return nil, fmt.Errorf("get context: %w", err)
	}
	defer rows.Close()

	var chunks []Chunk
	totalTokens := 0

	for rows.Next() {
		var c Chunk
		var score float64
		if err := rows.Scan(&c.ID, &c.Path, &c.StartLine, &c.EndLine, &c.Content, &c.Language, &score); err != nil {
			return nil, fmt.Errorf("scan: %w", err)
		}

		// Estimate tokens (~4 chars per token)
		tokens := (len(c.Content) + 3) / 4
		if totalTokens+tokens > maxTokens {
			break
		}

		chunks = append(chunks, c)
		totalTokens += tokens
	}

	return chunks, rows.Err()
}

// GetFile retrieves a file by path.
func (idx *SQLiteIndex) GetFile(ctx context.Context, path string) (*File, error) {
	idx.mu.RLock()
	defer idx.mu.RUnlock()

	if idx.closed {
		return nil, ErrClosed
	}

	var f File
	var fileID int64
	err := idx.db.QueryRowContext(ctx, `
		SELECT id, path, content, language, size, mod_time, hash
		FROM files WHERE path = ?
	`, path).Scan(&fileID, &f.Path, &f.Content, &f.Language, &f.Size, &f.ModTime, &f.Hash)
	if err == sql.ErrNoRows {
		return nil, ErrNotFound
	}
	if err != nil {
		return nil, fmt.Errorf("get file: %w", err)
	}

	// Load symbols
	rows, err := idx.db.QueryContext(ctx, `
		SELECT name, kind, path, line, column, end_line, signature, documentation, parent
		FROM symbols WHERE file_id = ?
	`, fileID)
	if err != nil {
		return nil, fmt.Errorf("get symbols: %w", err)
	}
	defer rows.Close()

	for rows.Next() {
		var s Symbol
		var kindStr string
		if err := rows.Scan(&s.Name, &kindStr, &s.Path, &s.Line, &s.Column,
			&s.EndLine, &s.Signature, &s.Documentation, &s.Parent); err != nil {
			return nil, fmt.Errorf("scan symbol: %w", err)
		}
		s.Kind = SymbolKind(kindStr)
		f.Symbols = append(f.Symbols, s)
	}

	return &f, nil
}

// GetChunk retrieves a chunk by ID.
func (idx *SQLiteIndex) GetChunk(ctx context.Context, id string) (*Chunk, error) {
	idx.mu.RLock()
	defer idx.mu.RUnlock()

	if idx.closed {
		return nil, ErrClosed
	}

	var c Chunk
	err := idx.db.QueryRowContext(ctx, `
		SELECT id, path, start_line, end_line, content, language, hash
		FROM chunks WHERE id = ?
	`, id).Scan(&c.ID, &c.Path, &c.StartLine, &c.EndLine, &c.Content, &c.Language, &c.Hash)
	if err == sql.ErrNoRows {
		return nil, ErrNotFound
	}
	if err != nil {
		return nil, fmt.Errorf("get chunk: %w", err)
	}

	return &c, nil
}

// Stats returns index statistics.
func (idx *SQLiteIndex) Stats(ctx context.Context) (*IndexStats, error) {
	idx.mu.RLock()
	defer idx.mu.RUnlock()

	if idx.closed {
		return nil, ErrClosed
	}

	stats := &IndexStats{
		Languages: make(map[string]int),
	}

	idx.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM files").Scan(&stats.FileCount)
	idx.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM chunks").Scan(&stats.ChunkCount)
	idx.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM symbols").Scan(&stats.SymbolCount)
	idx.db.QueryRowContext(ctx, "SELECT COALESCE(SUM(size), 0) FROM files").Scan(&stats.TotalSize)
	idx.db.QueryRowContext(ctx, "SELECT COALESCE(MAX(updated_at), 0) FROM files").Scan(&stats.LastUpdated)

	rows, _ := idx.db.QueryContext(ctx, "SELECT language, COUNT(*) FROM files GROUP BY language")
	if rows != nil {
		defer rows.Close()
		for rows.Next() {
			var lang string
			var count int
			if rows.Scan(&lang, &count) == nil {
				stats.Languages[lang] = count
			}
		}
	}

	return stats, nil
}

// Clear removes all data from the index.
func (idx *SQLiteIndex) Clear(ctx context.Context) error {
	idx.mu.Lock()
	defer idx.mu.Unlock()

	if idx.closed {
		return ErrClosed
	}

	_, err := idx.db.ExecContext(ctx, `
		DELETE FROM symbols_fts;
		DELETE FROM symbols;
		DELETE FROM chunks_fts;
		DELETE FROM chunks;
		DELETE FROM files;
	`)
	return err
}

// Close closes the index.
func (idx *SQLiteIndex) Close() error {
	idx.mu.Lock()
	defer idx.mu.Unlock()

	if idx.closed {
		return nil
	}

	idx.closed = true
	return idx.db.Close()
}

// Helper functions

func buildFTSQuery(query string) string {
	// Escape special characters and build query
	words := strings.Fields(query)
	var parts []string
	for _, word := range words {
		// Escape quotes
		word = strings.ReplaceAll(word, "\"", "\"\"")
		parts = append(parts, "\""+word+"\"")
	}
	return strings.Join(parts, " OR ")
}

func findMatchingLine(content, query string, startLine int) (int, string) {
	lines := strings.Split(content, "\n")
	queryLower := strings.ToLower(query)

	for i, line := range lines {
		if strings.Contains(strings.ToLower(line), queryLower) {
			return startLine + i, line
		}
	}

	if len(lines) > 0 {
		return startLine, lines[0]
	}
	return startLine, ""
}

func getContext(content string, line, contextLines int) ([]string, []string) {
	lines := strings.Split(content, "\n")

	var before, after []string

	startIdx := line - 1 - contextLines
	if startIdx < 0 {
		startIdx = 0
	}
	endIdx := line - 1 + contextLines + 1
	if endIdx > len(lines) {
		endIdx = len(lines)
	}

	if line-1 > 0 {
		for i := startIdx; i < line-1 && i < len(lines); i++ {
			before = append(before, lines[i])
		}
	}

	if line < len(lines) {
		for i := line; i < endIdx && i < len(lines); i++ {
			after = append(after, lines[i])
		}
	}

	return before, after
}
